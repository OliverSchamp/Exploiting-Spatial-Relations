import numpy as np
import matplotlib.pyplot as plt
import PIL
import cv2
import os
import random
import json
import pandas as pd

#############################

def make_synthetic_data(amount=100):
    categories = [
        {
            "supercategory": "none",
            "name": "figure",
            "id": 1
        },
        {
            "supercategory": "none",
            "name": "ball",
            "id": 0
        },
        {
            "supercategory": "none",
            "name": "goal",
            "id": 2
        },
        {
            "supercategory": "none",
            "name": "table",
            "id": 3
        }
    ]

    path = r"data/"
    json_file = "{}.json".format('synth_labels')

    res_file = {
        "categories": categories,
        "images": [],
        "annotations": []
    }

    annot_count = 0
    image_id = 0
    processed = 0
    # image_list = os.listdir(path)

    # # shuffle the image list, then have an if statement which does different behaviour if above i
    # random.Random(4).shuffle(image_list)
    # random.Random(4).shuffle(annot_labels)

    #consecutive frame generation
    pos_funcs = []
    x = np.linspace(0, np.pi/2, amount)
    shift_freqs = np.arange(8) * 2
    rotation_freqs = np.arange(8) * 2
    np.random.shuffle(shift_freqs)
    np.random.shuffle(rotation_freqs)
    frequencies = list(np.concatenate((shift_freqs, rotation_freqs), axis=0) + 1)
    for q in range(16):
        f = frequencies[q]
        temp = np.sin(f*x)*np.sin(f*x)
        pos_funcs.append(temp)

    for func in pos_funcs:
        plt.plot(func)

    plt.xlabel('Frame')
    plt.ylabel('Horizontal shift/ player length input')
    plt.title('Signals used to create synthetic consecutive frames')
    plt.show()

    df = pd.DataFrame()
    array_list = pos_funcs

    for i, arr in enumerate(array_list):
        column_name = f'Column_{i + 1}'
        df[column_name] = arr

    df.to_csv('sine_inputs.csv', index=False)

    for i in range(amount):

        img, annot_labels = generate_table(pos_func=pos_funcs, iter=i)

        #add noise to the image
        # img = img + 100*np.random.randn(img.shape[0], img.shape[1], img.shape[2])
        # img = np.clip(img, 0 ,255).astype(np.uint8)

        img_file = str(i) + '.png'
        img = PIL.Image.fromarray(img)
        img.save('data/' + img_file)
        img_w, img_h = img.size

        img_elem = {"file_name": img_file,
                    "height": img_h,
                    "width": img_w,
                    "id": image_id}

        res_file["images"].append(img_elem)

        #for every line you have: class bbox
        count = 0
        # Strips the newline character annot_labels = [[class, bbox], [class, bbox]...]
        for boxx in annot_labels:
            count += 1
            # print("Line{}: {}".format(count, line.strip()))
            # id, x, y, w, h = line.split(' ')
            id = boxx[0]
            bbox = boxx[1]
            bbox_coco = [bbox[1], bbox[0], bbox[3]-bbox[1], bbox[2]-bbox[0]]
            annot_elem = {
                "id": annot_count,
                "bbox": bbox_coco,
                # "segmentation": list([poly]),
                "image_id": image_id,
                "ignore": 0,
                "category_id": int(id),
                "iscrowd": 0,
                "area": bbox_coco[2] * bbox_coco[3]
            }

            res_file["annotations"].append(annot_elem)
            annot_count += 1

        image_id += 1
        processed += 1
        if (i+1) % 50 == 0 and i != 0:
            print(i+1, 'samples generated')

    with open(json_file, "w") as f:
        json_str = json.dumps(res_file)
        f.write(json_str)

#######################################################

def translate_image(image, x, y, annotations):
    height, width, _ = image.shape
    translated_image = np.ones_like(image) * 255  # Initialize with white background

    # Compute the translation amount for x and y directions
    x_translation = int(round(x * width))
    y_translation = int(round(y * height))

    # Compute the new position of the rectangle
    new_x_start = max(0, x_translation)
    new_y_start = max(0, y_translation)
    new_x_end = min(width, width + x_translation)
    new_y_end = min(height, height + y_translation)

    # Compute the source region of the rectangle
    src_x_start = max(0, -x_translation)
    src_y_start = max(0, -y_translation)
    src_x_end = min(width, width - x_translation)
    src_y_end = min(height, height - y_translation)

    # Copy the translated region to the new position
    translated_image[new_y_start:new_y_end, new_x_start:new_x_end, :] = \
        image[src_y_start:src_y_end, src_x_start:src_x_end, :]

    # translate the annotations also
    for i, annot in enumerate(annotations):
        annotations[i] = [annot[0] + y_translation, annot[1] + x_translation, annot[2] + y_translation, annot[3] + x_translation]

    return translated_image, annotations


def superimpose_images(background_image, object_image):
    # Make sure both images have the same shape
    if background_image.shape != object_image.shape:
        raise ValueError("Background and object images must have the same shape.")

    # Create a copy of the background image
    composite_image = np.copy(background_image)

    # Find the indices where the object image is not white
    non_white_indices = np.any(object_image != [255, 255, 255], axis=-1)

    # Replace the corresponding pixels in the composite image with the object image pixels
    composite_image[non_white_indices] = object_image[non_white_indices]

    return composite_image

def generate_bar(player_height, player_length, number_rectangles, spacing, img_size, colour, bar_length = 300, bar_width = 4, player_width=6):
    # white image to start off with
    object_image = np.ones(img_size, dtype=np.uint8) * 255

    horizontal_start = (img_size[0]//2)-bar_width
    horizontal_end = (img_size[0]//2)+bar_width
    vertical_start = (img_size[1]//2)-bar_length
    vertical_end = (img_size[1]//2)+bar_length

    # Draw the bar
    object_image[horizontal_start:horizontal_end, vertical_start:vertical_end, :] = [0, 0, 0]

    # spacing = (vertical_end - vertical_start) // number_rectangles
    centre = ((vertical_end - vertical_start)//2) + vertical_start
    centre_v = ((horizontal_end - horizontal_start)//2) + horizontal_start
    if number_rectangles % 2 == 0:
        centres =[]
        for n in range(number_rectangles//2):
            lc = centre-((n+0.5)*spacing)
            rc = centre+((n+0.5)*spacing)
            centres.append((int(lc), centre_v))
            centres.append((int(rc), centre_v))
    else:
        centres = []
        centres.append((centre, centre_v))
        for n in range((number_rectangles-1)//2):
            lc = centre - ((n+1) * spacing)
            rc = centre + ((n+1) * spacing)
            centres.append((lc, centre_v))
            centres.append((rc, centre_v))

    annot_labels = []
    for c in centres:
        object_image[player_height + c[1] - player_length - bar_width:player_height + c[1] + player_length + bar_width, c[0] - player_width:c[0] + player_width, :] = colour
        #player 'arms'
        armlength=player_width//2
        object_image[c[1] - bar_width - armlength:c[1] + bar_width + armlength, c[0] - player_width-armlength:c[0] + player_width+armlength, :] = colour
        #draw rounded head
        cv2.circle(object_image, (c[0], player_height + c[1] - player_length - bar_width), player_width, colour, -1)
        # draw rounded tail
        cv2.circle(object_image, (c[0], player_height + c[1] + player_length + bar_width), player_width, colour, -1)

        # tlc = (player_height + c[1] - player_length - bar_width - player_width, c[0] - player_width)
        # brc = (player_height + c[1] + player_length + bar_width + player_width, c[0] + player_width)
        #some width in the bounding boxes
        tlc = (player_height + c[1] - player_length - bar_width - player_width, c[0] - player_width - armlength)
        brc = (player_height + c[1] + player_length + bar_width + player_width, c[0] + player_width + armlength)

        full_label = [tlc[0], tlc[1], brc[0], brc[1]]
        annot_labels.append(full_label)

        # # visualise
        # bbox = np.array([
        #     [tlc[1], tlc[0]],
        #     [brc[1], tlc[0]],
        #     [brc[1], brc[0]],
        #     [tlc[1], brc[0]],
        # ])
        # bbox = bbox.reshape((4, 2))
        #
        # cv2.polylines(object_image, [bbox], True, (0, 255, 0), 2)

    return object_image, annot_labels


def generate_table(length_mult=20, pos_func = None, iter = None):
    """

    :param length_mult:
    :param function:
    :param pos_func: a list of 16 arrays, each of which has N values, relating to the number of images to produce
    :return:
    """

    background_image = np.array(PIL.Image.open('background4.png')).astype(np.uint8)
    background_image = background_image[:, :, :3]

    # colours
    team1 = (200, 0, 0)
    team2 = (0, 0, 200)
    ph = 12 #player height multiplier with length

    #values here are hard-coded to the background image
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[0][iter] * length_mult)

    object_image, fig_annot = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=1, spacing=100,
                                img_size=background_image.shape, bar_length=300, colour=team1)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[1][iter] * length_mult)

    object_image1, fig_annot1 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=2, spacing=150,
                                 img_size=background_image.shape, bar_length=315, colour=team1)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[2][iter] * length_mult)

    object_image2, fig_annot2 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=3, spacing=120,
                                 img_size=background_image.shape, bar_length=330, colour=team2)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[3][iter] * length_mult)

    object_image3, fig_annot3 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=5, spacing=80,
                                 img_size=background_image.shape, bar_length=345, colour=team1)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[4][iter] * length_mult)

    object_image4, fig_annot4 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=5, spacing=80,
                                 img_size=background_image.shape, bar_length=360, colour=team2)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[5][iter] * length_mult)

    object_image5, fig_annot5 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=3, spacing=120,
                                 img_size=background_image.shape, bar_length=375, colour=team1)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[6][iter] * length_mult)

    object_image6, fig_annot6 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=2, spacing=150,
                                 img_size=background_image.shape, bar_length=390, colour=team2)
    if iter is None:
        pl = round(np.random.rand() * length_mult)
    else:
        pl = round(pos_func[7][iter] * length_mult)

    object_image7, fig_annot7 = generate_bar(player_height=round(ph*pl/length_mult), player_length=pl, number_rectangles=1, spacing=100,
                                 img_size=background_image.shape, bar_length=405, colour=team2)

    if iter is None:
        shft = (np.random.rand() - 0.5) / 12
    else:
        shft = (pos_func[8][iter] - 0.5) / 12
    object_image, fig_annot = translate_image(object_image, shft, -0.33, fig_annot)
    if iter is None:
        shft = (np.random.rand() - 0.5) / 6.5
    else:
        shft = (pos_func[9][iter] - 0.5) / 6.5
    object_image1, fig_annot1 = translate_image(object_image1, shft, -0.27, fig_annot1)  # distance 6
    if iter is None:
        shft = (np.random.rand() - 0.5) / 12
    else:
        shft = (pos_func[10][iter] - 0.5) / 12
    object_image2, fig_annot2 = translate_image(object_image2, shft, -0.205, fig_annot2)  # distance 6.5
    if iter is None:
        shft = (np.random.rand() - 0.5) / 20
    else:
        shft = (pos_func[11][iter] - 0.5) / 20
    object_image3, fig_annot3 = translate_image(object_image3, shft, -0.135, fig_annot3)  # distance 7
    if iter is None:
        shft = (np.random.rand() - 0.5) / 18
    else:
        shft = (pos_func[12][iter] - 0.5) / 18
    object_image4, fig_annot4 = translate_image(object_image4, shft, -0.06, fig_annot4)  # distance 7.5
    if iter is None:
        shft = (np.random.rand() - 0.5) / 8
    else:
        shft = (pos_func[13][iter] - 0.5) / 8
    object_image5, fig_annot5 = translate_image(object_image5, shft, 0.02, fig_annot5)  # distance 8
    if iter is None:
        shft = (np.random.rand() - 0.5) / 5
    else:
        shft = (pos_func[14][iter] - 0.5) / 5
    object_image6, fig_annot6 = translate_image(object_image6, shft, 0.105, fig_annot6)  # distance 8.5
    if iter is None:
        shft = (np.random.rand() - 0.5) / 9
    else:
        shft = (pos_func[15][iter] - 0.5) / 9
    object_image7, fig_annot7 = translate_image(object_image7, shft, 0.195, fig_annot7)  # distance 9

    #annotations for the figures:
    figannots = fig_annot + fig_annot1 + fig_annot2 + fig_annot3 + fig_annot4 + fig_annot5 + fig_annot6 + fig_annot7
    goal_tlc = (100, 580)
    goal_brc = (145, 690)
    table_tlc = (58, 345)
    table_brc = (663, 930)


    for i, annot in enumerate(figannots): #add the figure class
        # figannots[i] = [1, [annot[1], annot[0], annot[3], annot[2]]] #swapping of x and y after plots show wrong way round
        figannots[i] = [1, annot]

    table_annot = [[3, [table_tlc[0], table_tlc[1], table_brc[0], table_brc[1]]]]
    # table_annot = [[3, [table_tlc[1], table_tlc[0], table_brc[1], table_brc[0]]]]
    goal_annot = [[2, [goal_tlc[0], goal_tlc[1], goal_brc[0], goal_brc[1]]]]
    # goal_annot = [[2, [goal_tlc[1], goal_tlc[0], goal_brc[1], goal_brc[0]]]]

    total_annot = figannots + goal_annot + table_annot

    # Superimpose the object on the background
    composite_image = superimpose_images(background_image, object_image)
    composite_image = superimpose_images(composite_image, object_image1)
    composite_image = superimpose_images(composite_image, object_image2)
    composite_image = superimpose_images(composite_image, object_image3)
    composite_image = superimpose_images(composite_image, object_image4)
    composite_image = superimpose_images(composite_image, object_image5)
    composite_image = superimpose_images(composite_image, object_image6)
    composite_image = superimpose_images(composite_image, object_image7)

    return composite_image, total_annot

if __name__ == "__main__":
    make_synthetic_data(2000)